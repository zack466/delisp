(in-package :cl-user)

(defpackage delisp.python
  (:use :cl :delisp.printer)
  (:export #:python))

(in-package :delisp.python)

(defun python (code)
  (mapcar #'gen-statement code))

(defun gen-statements (statements)
  (mapcar #'gen-statement statements))

;; Binary operators
;; Be careful, chaining might not always work as intended
(defun binop-p (op)
  (or (symbol= op '+) (symbol= op '-)
      (symbol= op '*) (symbol= op '**)
      (symbol= op '/) (symbol= op '//)
      (symbol= op '%) (symbol= op '==)
      (symbol= op '<) (symbol= op '<=)
      (symbol= op '>) (symbol= op '>=)
      (symbol= op 'or) (symbol= op 'and)
      (symbol= op '!=) (symbol= op 'in)))

(defun gen-expr (expr &optional (parens t))
  (if (atom expr)
      (cond ((stringp expr) (emit (format nil "\"~a\"" expr))) 
            ((floatp expr) (emit (format nil "~f" expr)))
            ((null expr))
            (t (emit (format nil "~a" expr))))
      (let ((hd (car expr)))
      (cond
        ;; dot operator - equivalent to .
        ((symbol= 'dot! hd)
         (loop for cons on (cdr expr)
               do (gen-expr (car cons))
               when (cdr cons) do (emit ".")))

        ;; not
        ((symbol= 'not hd)
         (if parens (emit "("))
         (emit "not ")
         (gen-expr (cadr expr))
         (if parens (emit ")")))
        ;; tuple
        ((symbol= 'tuple! hd)
         (emit "(")
         (loop for cons on (cdr expr)
               do (gen-expr (car cons))
               when (cdr cons) do (emit ", "))
         (emit ")"))
        ;; list
        ((symbol= 'list! hd)
         (emit "[")
         (loop for cons on (cdr expr)
               do (gen-expr (car cons))
               when (cdr cons) do (emit ", "))
         (emit "]"))
        ;; indexing (elt arr idx)
        ;; For slicing, just use the slice function explicitly
        ((symbol= 'elt! hd)
         (gen-expr (cadr expr))
         (emit "[")
         (gen-expr (caddr expr))
         (emit "]"))
        ;; TODO: lambda
        ;; Binary operator (with parentheses to enforce precedence)
        ((binop-p hd)
         (if parens (emit "("))
         (loop for cons on (cdr expr)
               do (gen-expr (car cons))
               when (cdr cons) do (emit (format nil " ~a " hd)))
         (if parens (emit ")")))
        ;; Function call
        (t
          (gen-expr hd)
          (emit "(")
          (loop for cons on (cdr expr)
                do (gen-expr (car cons) nil)
                when (cdr cons) do (emit ", "))
          (emit ")"))))))

(defun gen-statement (statement &optional (newline t))
  (if (atom statement)
    (emit "~S" statement)
    (let ((hd (car statement)))
      (cond
        ;; (if <cond> (<body>*))
        ((symbol= 'if hd)
         (emit "if ")
         (gen-expr (cadr statement) nil)
         (emit ":" :newline :indent)
         (gen-statements (cddr statement))
         (emit :dedent)
         (if newline (emit :newline)))
        ;; chained if/else
        ;; (cond (test body*)*)
        ((symbol= 'cond hd)
         (gen-statement (cons 'if (cadr statement)) nil)
         (loop for cons on (cddr statement)
               do (if (symbol= 'else (caar cons))
                      (progn
                        (emit "else:" :newline :indent)
                        (gen-statements (cdar cons))
                        (emit :dedent)
                        (return))
                      (progn
                        (emit "elif ")
                        (gen-expr (caar cons) nil)
                        (emit ":" :newline :indent)
                        (gen-statements (cdar cons))
                        (emit :dedent)))))
        ;; for
        ((symbol= 'for hd)
         (emit "for ")
         (gen-expr (cadr statement) nil)
         (emit " in ")
         (assert (symbol= 'in (caddr statement)))
         (gen-expr (cadddr statement) nil)
         (emit ":" :newline :indent)
         (gen-statements (cddddr statement))
         (emit :dedent :newline))
        ;; while
        ((symbol= 'while hd)
         (emit "while ")
         (gen-expr (cadr statement) nil)
         (emit ":" :newline :indent)
         (gen-statements (cddr statement))
         (emit :dedent :newline))
        ;; assignment
        ((symbol= 'set! hd)
         (gen-expr (cadr statement) nil)
         (emit " = ")
         (gen-expr (caddr statement) nil)
         (emit :newline))
        ;; +=, -=, *=, /=, and //=
        ((symbol= 'inc! hd)
         (gen-expr (cadr statement) nil)
         (emit " += ")
         (gen-expr (caddr statement) nil)
         (emit :newline))
        ((symbol= 'dec! hd)
         (gen-expr (cadr statement) nil)
         (emit " -= ")
         (gen-expr (caddr statement) nil)
         (emit :newline))
        ((symbol= 'mul! hd)
         (gen-expr (cadr statement) nil)
         (emit " *= ")
         (gen-expr (caddr statement) nil)
         (emit :newline))
        ((symbol= 'div! hd)
         (gen-expr (cadr statement) nil)
         (emit " /= ")
         (gen-expr (caddr statement) nil)
         (emit :newline))
        ((symbol= 'idiv! hd)
         (gen-expr (cadr statement) nil)
         (emit " //= ")
         (gen-expr (caddr statement) nil)
         (emit :newline))
        ;; escape arbitrary strings
        ((symbol= '@escape hd)
         (mapcar #'(lambda (x) (emit x :newline)) (cdr statement)))
        ;; return
        ((symbol= 'return hd)
         (emit "return ")
         (gen-expr (cadr statement) nil)
         (emit :newline))
        ;; declare (use for imports and stuff)
        ((symbol= 'declare hd)
         (loop for cons on (cdr statement)
               do (emit (format nil "~a" (car cons)))
               when (cdr cons) do (emit " ")))

        ;; (def fname (args) body*)
        ((symbol= 'def hd)
         (emit (format nil "def ~a(" (cadr statement)))
         (loop for cons on (caddr statement)
               do (emit (format nil "~a" (car cons)))
               when (cdr cons) do (emit ", "))
         (emit "):" :newline :indent)
         (gen-statements (cdddr statement))
         (emit :dedent :newline))
        ;; TODO: class
        ;; Assume to be an expression
        (t
          (gen-expr statement nil)
          (emit :newline))))))
